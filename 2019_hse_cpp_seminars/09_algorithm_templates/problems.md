# Примечания
- Если что-то не будет компилироваться и ругаться на запись сложного типа, например:
`std::vector<T>::iterator`  
Попробуйте вместо нее написать  
`typename std::vector<T>::iterator`  
`typename` - это подсказка компилятору, что после этого слова вы напишите тип. В некоторых случаях компилятор действительно не может понять это без подсказки. В примере выше вместо `std::vector<T>::iterator` может быть что угодно сложное, обозначающее тип.
- Если тип принимаемого итератора - шаблонный параметр, назовите его осмысленно (то есть это должно быть что-то из `RandomIterator`, `BidirectionalIterator`, `ForwardIterator`, `InputIterator`, `OutputIterator`). Если не понимаете, о чем речь, игнорируйте этот пункт.
- Копипастить решения предыдущих задач для решения следующих - нормально.
- Важно каждое решение протестировать на паре примеров в main. Иначе все теряет смысл: тут очень важно заставить все компилироватьcя и работать.
- Если требуется реализовать аналог функции из `std::`, то саму эту функцию из `std::` использовать запрещено, если не сказано обратного (например, при реализации `Find` нельзя использовать `std::find`).

# 1.A
```c++
std::vector<i32>::const_iterator Find(std::vector<i32>& v, i32 value);
```
Написать функцию, которая возвращает итератор на первый элемент вектора, равный `value`. Если такого
нет, то надо вернуть итератор, равный `v.end()`.  
**Примечание**: здесь важно вернуть именно `std::vector<i32>::const_iterator` (для справки, методы `cbegin` и `cend` возвращают именно `std::vector<i32>::const_iterator`), потому что вектор принимается по константной ссылке. В остальных задачах,
где функция принимает диапазон, пишите просто `std::vector<i32>::iterator`.

# 1.B
```c++
std::vector<i32>::iterator Find(??? first, ??? last, i32 value);
```
Добавить поддержку диапазона вместо целого вектора.

# 1.C
```c++
template<???>
??? Find(??? first, ??? last, ??? value);
```
Добавить поддержку векторов любого типа, не только `i32`. Может получиться два шаблонных параметра.  
**Примечание**: `value` теперь может быть любого типа. Так что предполагать, что его дешево скопировать при передаче в качестве аргумента уже нельзя. Это знание тоже должно повлиять на вашу сигнатуру.

# 1.D
```c++
template<???>
??? Find(??? first, ??? last, ??? value);
```
Добавить поддержку любых итераторов, а не только итераторов вектора.

# 2.A
```c++
std::vector<i32>::const_iterator FindIf(const std::vector<i32>& v, ??? predicate);
```
Вернуть итератор на первый элемент `x`, такой, что `predicate(x)` равен `true`.  
**Примечание**: `predicate` должен иметь тип указателя на функцию, которая принимает `i32` и возвращает `bool`. Чтобы понять, как это записать, воспользуйтесь [примером](https://github.com/StrausMG/teaching/blob/master/2019_hse_cpp_seminars/09_algorithm_templates/function_pointer.cpp).

# 2.B
```c++
std::vector<i32>::iterator FindIf(??? first, ??? last, ??? predicate);
```
Добавить поддержку диапазона вместо целого вектора.

# 2.C
```c++
template<???>
??? FindIf(??? first, ??? last, ??? predicate);
```
Добавить поддержку векторов любого типа, не только `i32`.

# 2.D
```c++
template<???>
??? FindIf(??? first, ??? last, ??? predicate);
```
Добавить поддержку любых итераторов, а не только итераторов вектора. Вместе с этим добавить возможность передавать
не только указатель на фукнцию, а любую сущность, которую можно позвать: функции, лямбды, структуры с переопределенным `operator()` и т.д. Должно получиться два шаблонных параметра.

# 3.A
```c++
struct Less {
    bool operator()(i32 fisrt, i32 second) {
        ???
    }
};
```
Реализовать функтор `Less` (то есть структура/класс с переопределенным `operator()`), которая при вызове
принимает два `i32` и возвращает результат сравнения.  
**Примечание**: итак, что вообще происходит. `Less` - это структура. Значит, можно завести объект:  
`Less comparator;`  
После этого можно применять его согласно сигнатуре `operator()`:  
`comparator(10, 20)`

# 3.B
```c++
struct Less {
    template<???>
    bool operator()(??? first, ??? second) {
        ???
    }
};
```
Сделать `operator()` шаблонным, чтобы он поддерживал не только `i32`.  
**Примечание**: применяется все точно так же, как в задаче 3A.

# 3.С
```c++
template<???>
struct Less {
    ???    
};
```
Сделать шаблонным сам функтор (по сути просто написать template не над методом, а над `struct`), чтобы он поддерживал не только `i32`.  
**Примечание**: теперь, заводя переменную, нужно писать не `Less`, а `Less<SomeType>`. Полная аналогия с тем, как вы записываете не `std::vector`, а `std::vector<SomeType>`.

# 4.A
**Внимание**:
- обязательно убедитесь, что у вас решены и компилируются все предыдущие задачи
- в этой и всех задачах блока 4 можно и нужно использовать `std::sort` (то есть реализация каждой функции - это одна строка кода)
```c++
void Sort(std::vector<i32>& v);
```
Посортировать вектор!

# 4.B
**Внимание**:
```c++
template<???>
void Sort(??? first, ??? second);
```
Посортировать диапазон!

# 4.C
```c++
template<???>
void Sort(??? first, ??? second);
```
Добавить поддержку любых типов, не только `i32`!

# 4.D
```c++
template<???>
void Sort(??? first, ??? second, ??? comparator);
```
Добавить возможность передавать компаратор любой природы, то есть что угодно, что можно звать вот так:  
`comparator(a, b)`

# 4.E
```c++
template<???>
void Sort(???);
```
Переделать 4D так, чтобы передача компаратора была опциональной. То есть чтобы его не нужно было передавать,
если достаточно обычного `operator<`.  
**Примечание**: вам помогут такие знания:
- шаблонные параметры могут иметь дефолтные значения
- аргументы функции могут иметь дефолтные значения
- вам нужен `Less` из задачи 3B

# 4.F
```c++
template<???>
void Sort(???);
```
Аналогично 4E, но чтобы использовался `Less` из задачи 3C.  
**Примечание**: когда вы захотите сделать дефолтное значение шаблонного параметра, который относится к типу компаратора, вам понадобится умение по итератору понимать тип объекта, на который он указывает. Итак, пусть у вас есть тип итератора `MyIterator` (это может как конкретный тип в духе `std::vector<i32>::iterator` так и параметр шаблона, например `RandomIterator`). Тогда тип значения, на который он указывает, вот такой:  
`std::iterator_traits<MyIterator>::value_type`.  
Весьма вероятно, что при решении задачи вам понадобится самый первый пункт из примечания в самом начале этого файла.

# 5.A
Если предыдущие задачи компилируются, сигнатура функции из 4F похожа на апокалипсис и желание перестать писать на С++ выросло на 1234%, то поздравляю, пятерка в дневник и в журнал.
